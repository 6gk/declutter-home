* Dotfiles - Origin and History
The origin of dotfiles is due to a bug in =ls=^{[1]}. Unix creators wanted
=ls= to hide =.= and =..= but due to a bug in =ls=, it hid all the files
and directories starting with a dot.
Many people exploited this bug and it became a "feature".
** Side note
As a side note, in Plan 9, dotfiles were completely removed and replaced
by a sane alternative. Every configuration file (and other files you would hide)
in Plan 9 would be stored in =$HOME/lib= akin to =$HOME/.config=.
* Freedesktop's XDG environment variables
Freedesktop's XDG env vars^{[2]} like =XDG_CACHE_HOME=,
=XDG_CONFIG_HOME= and many more is a key to keep
your home directory tidy because nine out of ten
software follows them. If they don't follow those
conventions, most of them have a flag to change
paths the software use for something.

Make sure to set them as they tend to drastically reduce
the clutter in your home directory.
* More env vars
A lot of Unix tools is notorious for creating dotfiles and cluttering your
home directory (wget, less for example). But most of these read an env var
that points to the path of the configuration file or has a flag that
changes some kind of path. Some of these and their
env var/flag will be listed below for your benefit. If something that you use
isn't here, check the man page and make sure to make an issue so people
in the future can benefit too!

| Tool          | Env var                       | Flag                      |
|---------------+-------------------------------+---------------------------|
| less          | =LESSHISTFILE=                | -                         |
| gnupg         | =GNUPGHOME=                   | -                         |
| readline      | =INPUTRC=                     | -                         |
| ksh^*         | =ENV=                         | -                         |
| zsh^*         | =ZDOTDIR=                     | -                         |
| dialog        | =DIALOGRC=                    | -                         |
| mail          | =MAIL=                        | -                         |
| shell-history | =HISTFILE=                    | -                         |
| xauth         | =XAUTHORITY=                  | -                         |
| python        | =PYTHONPATH= =PYTHONUSERBASE= | -                         |
| wget          | -                             | =--no-hsts= =--hsts-file= |

- If you're a mksh user, when you compile, you can change the MKSHRC_PATH definition
- If you're a zsh user, you can set =ZDOTDIR= in =/etc/zsh/zshenv= [3]
* Workarounds
These are merely workarounds and should be avoided whenever possible
but still these are worth it as a last ditch effort when the software
that creates these pesky dotfiles is proprietary.

This is what I do for Java and Minecraft (and for some browsers because
it takes ages to change the directory in the source code).
** How to do it
As said before, this is a workaround and should be avoided as much as possible.
To achieve this, you will be creating a user so that all the dotfiles will be
dumped into that user's home directory so that your home directory will be uncluttered.
This is easier said than done though because launching the application might be a bit
difficult so you might have to configure sudo (or doas) to launch a wrapper as that
user without needing to type the password.
** Bright side
On the bright side, not really every software needs the previously mentioned workaround.
In fact, from my experience, only two software needed this (and those have been mentioned
at the start of the previous section). A much simpler way to execute this would be to
simply write a wrapper script like the following. In the example, I will be using Firefox.
#+BEGIN_SRC sh
#!/bin/sh
HOME=${HOME}/some_other_dir firefox
#+END_SRC
Whenever you launch firefox via this wrapper, all the dotfiles will go to
=${HOME}/some_other_dir= instead of =${HOME}=.

NOTE: This is one of the simplest way to unclutter your home directory.
* Bruteforcing
What if the software you're using doesn't have an env var and you don't want to use
ugly workarounds? Well, you can patch the software if the source is available. Patching
software (especially when you're simply changing a variable) is a lot easier than you
might think. Sometimes, you wouldn't even have the need to change the source code because
some software allows the user to set the configuration path (or whatever else) to be set
on compilation time. So instead of changing the source code, you would merely change a
variable in the Makefile.

You can find the patches that I made for various software (mksh, emacs, dosbox) to change
the configuration (or whatever else) path here -
https://github.com/vizs/home/tree/master/etc/prog.d/patches
** A rough outline on the process
Usually, =grep= and a bit of time is all you need to change the path. Most likely, all
you need to do is search for a typical string like =.software= in every file in the
source directory and change it (and make a patch). You can do this by simply running
=grep -R '\.software' *= (assuming you're in the source directory). Then using your
favorite editor, change the necessary lines.
* Before and Aftek
* References
[1] http://xahlee.info/UnixResource_dir/writ/unix_origin_of_dot_filename.html

[2] https://specifications.freedesktop.org/basedir-spec/latest/ar01s03.html

[3] https://github.com/vizs/declutter-home/issues/1
